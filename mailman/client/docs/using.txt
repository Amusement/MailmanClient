===================
Mailman REST client
===================

This is the official Python bindings for the GNU Mailman REST API.  In order
to talk to Mailman, the engine's REST server must be running.  You begin by
instantiating a client object to access the root of the REST hierarchy,
providing it the base URL, user name and password (for Basic Auth).

    >>> from mailman.client import Client
    >>> client = Client('http://localhost:8001/3.0', 'restadmin', 'restpass')

We can retrieve basic information about the server.

    >>> dump(client.system)
    http_etag: "..."
    mailman_version: GNU Mailman 3.0... (...)
    python_version: ...
    self_link: http://localhost:8001/3.0/system

To start with, there are no known mailing lists.

    >>> client.lists
    []


Domains
=======

Before new mailing lists can be added, the domain that the list will live in
must be added.  By default, there are no known domains.

    >>> client.domains
    []

It's easy to create a new domain; when you do, a proxy object for that domain
is returned.

    >>> example_dot_com = client.create_domain('example.com')
    >>> example_dot_com
    <Domain "example.com">
    >>> print example_dot_com.base_url
    http://example.com
    >>> print example_dot_com.contact_address
    postmaster@example.com
    >>> print example_dot_com.description
    None
    >>> print example_dot_com.email_host
    example.com
    >>> print example_dot_com.url_host
    example.com

You can also get an existing domain independently.

    >>> example = client.get_domain('example.com')
    >>> example
    <Domain "example.com">
    >>> print example_dot_com.base_url
    http://example.com

But you cannot retrieve a non-existent domain.

    >>> client.get_domain('example.org')
    Traceback (most recent call last):
    ...
    HTTPError: HTTP Error 404: 404 Not Found

After creating a few more domains, we can print the list of all domains.

    >>> client.create_domain('example.net')
    <Domain "example.net">
    >>> client.create_domain('example.org')
    <Domain "example.org">
    >>> for email_host in client.domains:
    ...     print email_host
    <Domain "example.com">
    <Domain "example.net">
    <Domain "example.org">


Mailing lists
=============

Once you have a domain, you can create mailing lists in that domain.

    >>> test_one = example.create_list('test-one')
    >>> test_one
    <List "test-one@example.com">
    >>> print test_one.fqdn_listname
    test-one@example.com
    >>> print test_one.host_name
    example.com
    >>> print test_one.list_name
    test-one
    >>> print test_one.real_name
    Test-one

You can also retrieve the mailing list after the fact.

    >>> my_list = client.get_list('test-one@example.com')
    >>> my_list
    <List "test-one@example.com">

And you can print all the known mailing lists.
::

    >>> example.create_list('test-two')
    <List "test-two@example.com">
    >>> domain = client.get_domain('example.net')
    >>> domain.create_list('test-three')
    <List "test-three@example.net">
    >>> example.create_list('test-three')
    <List "test-three@example.com">

    >>> for mlist in client.lists:
    ...     print mlist
    <List "test-one@example.com">
    <List "test-three@example.com">
    <List "test-three@example.net">
    <List "test-two@example.com">

You can use a list instance to delete the list.

    >>> test_three = client.get_list('test-three@example.net')
    >>> test_three.delete()

You can also delete a list using the client instance's delete_list method.

    >>> client.delete_list('test-three@example.com')

    >>> for mlist in client.lists:
    ...     print mlist
    <List "test-one@example.com">
    <List "test-two@example.com">


Membership
==========

Email addresses can subscribe to existing mailing lists, becoming members of
that list.  The address is a unique id for a specific user in the system, and
a member is a user that is subscribed to a mailing list.  Email addresses need
not be pre-registered, though the auto-registered user will be unique for each
email address.

The system starts out with no members.

    >>> client.members
    []

New members can be easily added; users are automatically registered.
::

    >>> test_two = client.get_list('test-two@example.com')

    >>> test_one.subscribe('anna@example.com', 'Anna')
    <Member "anna@example.com" on "test-one@example.com">
    >>> test_one.subscribe('bill@example.com', 'Bill')
    <Member "bill@example.com" on "test-one@example.com">
    >>> test_two.subscribe('anna@example.com')
    <Member "anna@example.com" on "test-two@example.com">
    >>> test_two.subscribe('cris@example.com', 'Cris')
    <Member "cris@example.com" on "test-two@example.com">

We can retrieve all known memberships.  These are sorted first by mailing list
name, then by email address.

    >>> for member in client.members:
    ...     print member
    <Member "anna@example.com" on "test-one@example.com">
    <Member "bill@example.com" on "test-one@example.com">
    <Member "anna@example.com" on "test-two@example.com">
    <Member "cris@example.com" on "test-two@example.com">

We can also view the memberships for a single mailing list.

    >>> for member in test_one.members:
    ...     print member
    <Member "anna@example.com" on "test-one@example.com">
    <Member "bill@example.com" on "test-one@example.com">

We can get a single membership too.

    >>> cris = test_two.get_member('cris@example.com')
    >>> cris
    <Member "cris@example.com" on "test-two@example.com">
    >>> print cris.role
    member
    >>> print cris.self_link
    http://localhost:8001/3.0/members/4
    >>> print cris.user
    http://localhost:8001/3.0/users/3

If you use an address which is not a member of test_two `ValueError` is raised:

    >>> test_two.unsubscribe('nomember@example.com')
    Traceback (most recent call last):
    ...
    ValueError: nomember@example.com is not a member address of test-two@example.com

After a while, Anna decides to unsubscribe from the Test One mailing list,
though she keeps her Test Two membership active.

    >>> test_one.unsubscribe('anna@example.com')
    >>> for member in client.members:
    ...     print member
    <Member "bill@example.com" on "test-one@example.com">
    <Member "anna@example.com" on "test-two@example.com">
    <Member "cris@example.com" on "test-two@example.com">

A little later, Cris decides to unsubscribe from the Test Two mailing list.

    >>> cris.unsubscribe()
    >>> for member in client.members:
    ...     print member
    <Member "bill@example.com" on "test-one@example.com">
    <Member "anna@example.com" on "test-two@example.com">

If you try to unsubscribe an address which is not a member address `ValueError` is raised:

    >>> test_one.unsubscribe('nomember@example.com')
    Traceback (most recent call last):
    ...
    ValueError: nomember@example.com is not a member address of test-one@example.com


List Settings
=============

We can get all list settings via a lists settings attribute. A proxy object for the settings is returned which behaves much like a dictionary.

    >>> settings = test_one.settings
    >>> len(settings)
    48

    >>> for attr in sorted(settings):
    ...     print attr + ': ' + str(settings[attr])
    acceptable_aliases: []
    ...
    welcome_msg:

    >>> print settings['real_name']
    Test-one

We can access all valid list settings as attributes.

    >>> settings['fqdn_listname']
    u'test-one@example.com'
    >>> print settings['description']

    >>> settings['description'] = u'A very meaningful description.'
    >>> settings['real_name'] = u'Test Numero Uno'

    >>> settings.save()

    >>> settings_new = test_one.settings
    >>> print settings_new['description']
    A very meaningful description.
    >>> print settings_new['real_name']
    Test Numero Uno


